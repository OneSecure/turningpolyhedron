//test procedural texture generate

struct VS_OUTPUT{
float4 p:POSITION,p0:TEXCOORD0;
};

float4x4 mat;

texture texNoise;
sampler sampNoise=sampler_state{
Texture=<texNoise>;
MipFilter=NONE;
MinFilter=POINT;
MagFilter=POINT;
AddressU=WRAP;
AddressV=WRAP;
};

texture tex;
sampler samp=sampler_state{
Texture=<tex>;
MipFilter=NONE;
MinFilter=LINEAR;
MagFilter=LINEAR;
AddressU=CLAMP;
AddressV=CLAMP;
};

float4 pixelSize;

////////

VS_OUTPUT vs_func(float4 p:POSITION){
VS_OUTPUT d;
d.p=mul(p,mat);
d.p0=p;
return d;
}

//out: (-1,-1)->(1,1) depth:near=0 far=1 (?)

//render to texture
//TODO:
VS_OUTPUT vs_func_rtt(float4 p:POSITION,float2 t0:TEXCOORD0){
VS_OUTPUT d;
d.p=float4(t0.x*2-1,1-t0.y*2,0.5,1);
//d.p=float4(t0.x,t0.y,0.5,1);
d.p0=p;
return d;
}

//IT WORKS!!!

float simplexnoise(float3 p){
float n=0.0f;
float3 i=floor(p+(p.x+p.y+p.z)/3.0f);
float3 x0=p-(i-(i.x+i.y+i.z)/6.0f);
float3 i1,i2;
//TODO:change
    if(x0.x>=x0.y) {
      if(x0.y>=x0.z)
        { i1=float3(1,0,0); i2=float3(1,1,0); } // X Y Z order
        else if(x0.x>=x0.z) { i1=float3(1,0,0); i2=float3(1,0,1); } // X Z Y order
        else { i1=float3(0,0,1); i2=float3(1,0,1); } // Z X Y order
      }
    else { // x0<y0
      if(x0.y<x0.z) { i1=float3(0,0,1); i2=float3(0,1,1); } // Z Y X order
      else if(x0.x<x0.z) { i1=float3(0,1,0); i2=float3(0,1,1); } // Y Z X order
      else { i1=float3(0,1,0); i2=float3(1,1,0); } // Y X Z order
    }
float3 x1=x0-i1+1/6.0f;
float3 x2=x0-i2+1/3.0f;
float3 x3=x0-0.5f;
//i=64.0f*frac(i/64.0f);
i/=64.0f;
//
float t=0.6f-dot(x0,x0);
if(t>0){
 t*=t;
 n+=t*t*dot(tex2D(sampNoise,float2(tex2D(sampNoise,i.xy).x,i.z)).xyz-0.5f,x0);
}
t=0.6f-dot(x1,x1);
if(t>0){
 t*=t;
 i1/=64.0f;
 n+=t*t*dot(tex2D(sampNoise,float2(tex2D(sampNoise,i.xy+i1.xy).x,i.z+i1.z)).xyz-0.5f,x1);
}
t=0.6f-dot(x2,x2);
if(t>0){
 t*=t;
 i2/=64.0f;
 n+=t*t*dot(tex2D(sampNoise,float2(tex2D(sampNoise,i.xy+i2.xy).x,i.z+i2.z)).xyz-0.5f,x2);
}
t=0.6f-dot(x3,x3);
if(t>0){
 i+=1/64.0f;
 t*=t;
 n+=t*t*dot(tex2D(sampNoise,float2(tex2D(sampNoise,i.xy).x,i.z)).xyz-0.5f,x3);
}
//xxx
return n*64.0f;
}

float4 ps_func(VS_OUTPUT d):COLOR0{

float a=0,b=1,c=1;
int i;


//normal --> rock
for(i=0;i<6;i++){
 a+=simplexnoise(d.p0.xyz*c+i)*b;
 b*=0.86;c*=1.85;
}
a=smoothstep(-1.0,1.0,a);
return lerp(float4(44,36,35,255)/255.0f,float4(211,120,93,255)/255.0f,a);


/*
//abs --> marble
for(i=0;i<4;i++){
 a+=abs(simplexnoise(d.p0.xyz*c+i))*b;
 b*=0.6;c*=2.5;
}
a=pow(a/1.5,0.3);

//add some noise
float3 n=tex2D(sampNoise,float2(tex2D(sampNoise,d.p0.xy*16.18033).x,d.p0.z*16.18033)).xyz-0.5f;
//return float4(a+n,1);
a=a+n.x/8.0f;
return float4(a,a,a,1);
*/
}

technique test{
pass{
VertexShader=compile vs_2_0 vs_func();
PixelShader=compile ps_3_0 ps_func();
}
}

technique test_rtt{
pass{
VertexShader=compile vs_2_0 vs_func_rtt();
PixelShader=compile ps_3_0 ps_func();
}
}

////////generate mipmap

float4 mipmap4_func(float2 t:TEXCOORD0):COLOR0{
return (tex2D(samp,t)+tex2D(samp,float2(t.x+pixelSize.x,t.y))
+tex2D(samp,float2(t.x,t.y+pixelSize.y))
+tex2D(samp,float2(t.x+pixelSize.x,t.y+pixelSize.y)))/4.0f;
}

technique mipmap4{
pass{
PixelShader=compile ps_2_0 mipmap4_func();
}
}

////////process texture

float4 grayscale_func(float2 t:TEXCOORD0):COLOR0{
float f=dot(tex2D(samp,t),float4(0.222,0.707,0.071,0));
return float4(f,f,f,1);
}

technique grayscale{
pass{
PixelShader=compile ps_2_0 grayscale_func();
}
}

float4 normal_func(float2 t:TEXCOORD0):COLOR0{
float4 clr;
///
float4 f=float4(
tex2D(samp,float2(t.x-pixelSize.x,t.y-pixelSize.y)).x,
tex2D(samp,float2(t.x-pixelSize.x,t.y+pixelSize.y)).x,
tex2D(samp,float2(t.x+pixelSize.x,t.y-pixelSize.y)).x,
tex2D(samp,float2(t.x+pixelSize.x,t.y+pixelSize.y)).x);
/// (-) ???
clr.x=-(f.z+f.w+tex2D(samp,float2(t.x+pixelSize.x,t.y)).x*2.0f
-f.x-f.y-tex2D(samp,float2(t.x-pixelSize.x,t.y)).x*2.0f);
clr.y=-(f.y+f.w+tex2D(samp,float2(t.x,t.y+pixelSize.y))*2.0f
-f.x-f.z-tex2D(samp,float2(t.x,t.y-pixelSize.y)).x*2.0f);
///
clr.z=sqrt(1.0f-clr.x*clr.x-clr.y*clr.y);
clr.w=1;
return (clr+1.0f)*0.5f;
}

technique normal_map{
pass{
PixelShader=compile ps_2_0 normal_func();
}
}

float4 expand4_func(float2 t:TEXCOORD0):COLOR0{
float4 c,clr=tex2D(samp,t);
c=tex2D(samp,float2(t.x,t.y-pixelSize.y));
clr=clr.w<0.5f?c:clr;
c=tex2D(samp,float2(t.x,t.y+pixelSize.y));
clr=clr.w<0.5f?c:clr;
c=tex2D(samp,float2(t.x-pixelSize.x,t.y));
clr=clr.w<0.5f?c:clr;
c=tex2D(samp,float2(t.x+pixelSize.x,t.y));
clr=clr.w<0.5f?c:clr;
return clr;
}

technique expand4{
pass{
PixelShader=compile ps_2_0 expand4_func();
}
}

float4 expand8_func(float2 t:TEXCOORD0):COLOR0{
float4 c,clr=tex2D(samp,t);
c=tex2D(samp,float2(t.x,t.y-pixelSize.y));
clr=clr.w<0.5f?c:clr;
c=tex2D(samp,float2(t.x,t.y+pixelSize.y));
clr=clr.w<0.5f?c:clr;
c=tex2D(samp,float2(t.x-pixelSize.x,t.y));
clr=clr.w<0.5f?c:clr;
c=tex2D(samp,float2(t.x+pixelSize.x,t.y));
clr=clr.w<0.5f?c:clr;
c=tex2D(samp,float2(t.x-pixelSize.x,t.y-pixelSize.y));
clr=clr.w<0.5f?c:clr;
c=tex2D(samp,float2(t.x-pixelSize.x,t.y+pixelSize.y));
clr=clr.w<0.5f?c:clr;
c=tex2D(samp,float2(t.x+pixelSize.x,t.y-pixelSize.y));
clr=clr.w<0.5f?c:clr;
c=tex2D(samp,float2(t.x+pixelSize.x,t.y+pixelSize.y));
clr=clr.w<0.5f?c:clr;
return clr;
}

technique expand8{
pass{
PixelShader=compile ps_2_0 expand8_func();
}
}
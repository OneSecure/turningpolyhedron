#ifndef __ColorZoneSolver__
#define __ColorZoneSolver__

#include "SimpleSolver.h"

#define ColorZoneColorsMax 16

static const char* ColorZoneColors[ColorZoneColorsMax][2]={
	{"BLUE","0.1,0.1,0.4"},
	{"RED","0.4,0.1,0.1"},
	{"GREEN","0.1,0.4,0.1"},
	{"YELLOW","0.4,0.4,0.1"},
	{"CYAN","0.1,0.4,0.4"},
	{"MAGENTA","0.4,0.1,0.4"},
	{"WHITE","0.4,0.4,0.4"},
	{"BLACK","0.1,0.1,0.1"},
	{"_QBColor1_","0.1,0.1,0.25"},
	{"_QBColor2_","0.1,0.25,0.1"},
	{"_QBColor3_","0.1,0.25,0.25"},
	{"_QBColor4_","0.25,0.1,0.1"},
	{"_QBColor5_","0.25,0.1,0.25"},
	{"_QBColor6_","0.25,0.25,0.1"},
	{"_QBColor7_","0.325,0.325,0.325"},
	{"_QBColor8_","0.25,0.25,0.25"},
};

class ColorZoneSolver:public SimpleBaseSolver{
protected:
	char *m_bMapData;
public:
	ColorZoneSolver(int w,int h,char *data=NULL):SimpleBaseSolver(w,h){
		m_bMapData=(char*)malloc(1<<(m_nWidthShift+m_nHeightShift));
		memset(m_bMapData,0,1<<(m_nWidthShift+m_nHeightShift));
		if(data){
			for(int j=0;j<h;j++){
				for(int i=0;i<w;i++) m_bMapData[(j<<m_nWidthShift)+i]=data[j*w+i];
			}
		}
	}
	char operator()(int x,int y) const{
		return m_bMapData[(y<<m_nWidthShift)+x];
	}
	char& operator()(int x,int y){
		return m_bMapData[(y<<m_nWidthShift)+x];
	}
	bool Solve(std::ostream* out,int* step,char* MovedArea,char* SolutionMovedArea,int* NodesUsed){
		const int d1[6][2]={
			{SizeX,SizeY},{SizeY,SizeX},{SizeX,SizeZ},{SizeZ,SizeX},{SizeY,SizeZ},{SizeZ,SizeY}
		};
		//
		unsigned char *b=(unsigned char*)m_bMapPassabilityData;
		const int w=1<<m_nWidthShift,h=1<<m_nHeightShift;
		memset(b,0,6<<(m_nWidthShift+m_nHeightShift));
		for(int idx=0;idx<6;idx++){
			int w1=d1[idx][0];
			int h1=d1[idx][1];
			for(int j=0;j<=h-h1;j++){
				for(int i=0;i<=w-w1;i++){
					int old_value=0;
					for(int jj=0;jj<h1;jj++){
						for(int ii=0;ii<w1;ii++){
							int value=m_bMapData[((j+jj)<<m_nWidthShift)+i+ii];
							if(!(value>0&&value<=ColorZoneColorsMax) || (old_value && value!=old_value)) goto _skip;
							old_value=value;
						}
					}
					b[(((idx<<m_nHeightShift)+j)<<m_nWidthShift)+i]=0x20;
_skip:
					(void)0;
				}
			}
		}
		//
		return SimpleBaseSolver::Solve(out,step,MovedArea,SolutionMovedArea,NodesUsed);
	}
	~ColorZoneSolver(){
		if(m_bMapData) free(m_bMapData);
	}
	void OutputXML(std::ostream& out,bool OutputSolution){
		out<<"<?xml version=\"1.0\" encoding=\"utf-8\" ?>\n"
			"<!-- Generated by ColorZoneSolver -->\n"
			"<level>\n";
		if(OutputSolution){
			out<<"\t<solution><![CDATA[";
			Solve(&out,NULL,NULL,NULL,NULL);
			out<<"]]></solution>\n";
		}
		//
		int nFlags=0;
		for(int j=0;j<m_nHeight;j++){
			for(int i=0;i<m_nWidth;i++){
				int value=m_bMapData[(j<<m_nWidthShift)+i];
				if(value>0&&value<=ColorZoneColorsMax) nFlags|=1<<(value-1);
			}
		}
		for(int i=0;i<ColorZoneColorsMax;i++){
			if(nFlags&(1<<i)){
				out<<"\t<tileType id=\""<<ColorZoneColors[i][0]<<"\" index=\"-"<<(i+1)<<"\">\n"
					"\t\t<appearance>\n"
					"\t\t\t<shader templateName=\"simple1_fixed\" ambient=\""<<ColorZoneColors[i][1]<<
					"\" diffuse=\""<<ColorZoneColors[i][1]<<"\" specular=\"0.4,0.4,0.3\" specularHardness=\"50\">\n"
					"\t\t\t\t<mesh type=\"cube\" s=\"1,1,0.25\" c=\"0,0,1\" bevel=\"1;0.05\" bevelNormalSmoothness=\"1\"/>\n"
					"\t\t\t</shader>\n"
					"\t\t</appearance>\n"
					"\t</tileType>\n";
			}
		}
		out<<"\t<tileMapping id=\"floating-goal\" index=\"-99\"/>\n";
		//
		out<<"\t<mapData id=\"m1\" shape=\"rect\" size=\""<<m_nWidth<<","<<m_nHeight<<",1\">\n"
			"\t\t<typeArray><![CDATA[";
		for(int j=0;j<m_nHeight;j++){
			for(int i=0;i<m_nWidth;i++){
				int value=m_bMapData[(j<<m_nWidthShift)+i];
				if(value>0&&value<=ColorZoneColorsMax) out<<(-value);
				out<<",";
			}
			out<<"\n";
		}
		out<<"]]></typeArray>\n"
			"\t\t<polyhedron id=\"main\" shape=\""<<SizeX<<"x"<<SizeY<<"x"<<SizeZ<<
			"\" p=\""<<StartX<<","<<StartY<<"\" tiltable=\"false\" supportable=\"false\" autoSize=\"true\">\n"
			"\t\t\t<appearance><shader templateName=\"simple1_fixed\" ambient=\"0.2,0.2,0.2\" diffuse=\"0.2,0.2,0.2\" specular=\"0.4,0.4,0.3\" specularHardness=\"50\">\n"
			"\t\t\t\t<mesh type=\"cube\" bevel=\"1;0.05\" bevelNormalSmoothness=\"1\"/>\n"
			"\t\t\t</shader></appearance>\n"
			"\t\t\t<onEnter condition=\"tileTypeCount=2~\" event=\"move:back\"/>\n"
			"\t\t</polyhedron>\n"
			"\t</mapData>\n"
			"\t<mapData id=\"overlay\" shape=\"rect\" p=\""<<EndX<<","<<EndY<<",0\" size=\""<<EndSizeX<<","<<EndSizeY<<",1\">\n"
			"\t\t<typeArray>-99*"<<(EndSizeX*EndSizeY)<<"</typeArray>\n"
			"\t</mapData>\n"
			"\t<winningCondition>\n"
			"\t\t<moveCondition src=\"main\" target=\"m1("<<EndX<<","<<EndY<<")\" targetSize=\""<<EndSizeX<<","<<EndSizeY<<"\"/>\n"
			"\t</winningCondition>\n"
			"</level>\n";
	}
};

#endif
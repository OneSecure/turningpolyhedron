//test custom render pipeline

struct VS_INPUT{
float4 p:POSITION;
float4 c:COLOR0;
float4 c1:COLOR1;
float4 t:TEXCOORD0;
float4 n:NORMAL;
float4 b:BINORMAL;
float4 ta:TANGENT;
};

struct VS_OUTPUT{
float4 _p:POSITION;
float4 c:COLOR0;
float4 c1:COLOR1;
float4 t:TEXCOORD0;//texture coord and z,w of camrea-space position
	//TEXCOORD0_centroid;
float4 p:TEXCOORD1;//pos
float4 n:TEXCOORD2;//normal
float4 b:TEXCOORD3;//binormal
float4 ta:TEXCOORD4;//tangent
float4 pShadow:TEXCOORD5;
};

struct VS_OUTPUT_SHADOW{
float4 _p:POSITION;
float4 c:TEXCOORD0; //fix color out of range bug (old:COLOR0)
};

struct VS_OUTPUT_VOLUMEFOG{
	float4 _p:POSITION;
	float4 c:COLOR0;//reserved
	float4 c1:COLOR1;//reserved
	float4 t:TEXCOORD0;//z,w of camrea-space position
};

//world matrix
float4x4 matWorld;

//Transpose[Inverse[world]] (?)
float4x4 matWorld1;

//world-view-proj matrix
float4x4 mat,matShadow;

//////// light settings

//directional light:direction
float4 lightDir;

//point light:pos
float4 lightPos;

//light type 0-directional 1-point
int lightType;

//0---ambient
//1---x:hardness y:parallax offset z:parallax scale
float4 _fParam[4];

////////other

float4 zData; //(c1,c2,0,0) such that z=1/(c1+c2*z')

////////

//view pos
float4 viewPos;

//texture
texture tex;
sampler samp=sampler_state{
Texture=<tex>;
MipFilter=NONE;
MinFilter=LINEAR;
MagFilter=LINEAR;
AddressU=CLAMP;
AddressV=CLAMP;
};

//normal (and height) map
texture texNormal;
sampler sampNormal=sampler_state{
Texture=<texNormal>;
MipFilter=NONE;
MinFilter=LINEAR;
MagFilter=LINEAR;
AddressU=CLAMP;
AddressV=CLAMP;
};

//TODO:specular map,hardness map,etc.

//shadow map
texture texShadow;
sampler sampShadow=sampler_state{
Texture=<texShadow>;
MipFilter=NONE;
MinFilter=LINEAR;
MagFilter=LINEAR;
AddressU=CLAMP;
AddressV=CLAMP;
};

//noise map
texture texNoise;
sampler sampNoise=sampler_state{
Texture=<texNoise>;
MipFilter=NONE;
MinFilter=POINT;
MagFilter=POINT;
AddressU=WRAP;
AddressV=WRAP;
};

VS_OUTPUT vs_func(VS_INPUT d0){
VS_OUTPUT d;
float4 p=mul(d0.p,mat);
d._p=p;
d.c=d0.c; //1
d.c1=d0.c1; //1
d.t=float4(d0.t.xy,p.zw);
d.p=mul(d0.p,matWorld);
d.n=mul(d0.n,matWorld1);
d.b=mul(d0.b,matWorld1);
d.ta=mul(d0.ta,matWorld1);
d.pShadow=mul(d0.p,matShadow);
////??
//d.pShadow.xyz/=d.pShadow.w;
//d.pShadow.xy*=float2(0.5f,-0.5f);
//d.pShadow.xy+=0.5f;
////
return d;
}

VS_OUTPUT_VOLUMEFOG vs_func_volumefog(VS_INPUT d0){
	VS_OUTPUT_VOLUMEFOG d;
	float4 p=mul(d0.p,mat);
	d._p=p;
	d.c=d0.c; //1
	d.c1=d0.c1; //1
	d.t=p;
	return d;
}

//test
float4 ps_func(VS_OUTPUT d):COLOR0{
	
	float depth=1.0f/(zData.x+zData.y*d.t.z/d.t.w);
	//float depth=length(d.p.xyz-viewPos.xyz);

float4 viewVec=normalize(viewPos-d.p);

//new:parallax mapping test
float4 clr_tex;
#if 1

//it works!! :)
clr_tex=float4(dot(viewVec,d.b),dot(viewVec,d.ta),0,0); //parallax_base // /dot(viewVec,d.n)
float4 parallax_offset=clr_tex*(tex2D(sampNormal,d.t).w+_fParam[1].y)*_fParam[1].z;
//iteration(?)
parallax_offset=(parallax_offset+clr_tex*(tex2D(sampNormal,d.t+parallax_offset).w+_fParam[1].y)*_fParam[1].z)*0.5f;
parallax_offset=(parallax_offset+clr_tex*(tex2D(sampNormal,d.t+parallax_offset).w+_fParam[1].y)*_fParam[1].z)*0.5f;

d.t+=parallax_offset;

#endif

//get texture color
clr_tex=tex2D(samp,d.t);

//shadow map test
float4 l=1.0f;

#if 0

d.pShadow.xyz/=d.pShadow.w;
d.pShadow.xy*=float2(0.5f,-0.5f);
d.pShadow.xy+=0.5f;

//if(d.pShadow.z/d.pShadow.w>
//tex2D(sampShadow,(d.pShadow.xy/d.pShadow.w)*float2(0.5f,-0.5f)+0.5f).x)
//return d.c*clr_tex*0.3f; //TODO:ambient

float2 dist=d.pShadow.z-tex2D(sampShadow,d.pShadow.xy).x;

if(dist.x>0) //return d.c*clr_tex*0.3f;
{
 //test "soft" shadow TODO:dithering and distance factor
 dist*=tex2D(sampNoise,d.pShadow.xy*(1.6180339*8.0f)).xy;
 l=1.0f
 -((d.pShadow.z>tex2D(sampShadow,d.pShadow.xy+dist).x)?0.25f:0)
 -((d.pShadow.z>tex2D(sampShadow,d.pShadow.xy-dist).x)?0.25f:0)
 -((d.pShadow.z>tex2D(sampShadow,d.pShadow.xy+float2(dist.y,-dist.x)).x)?0.25f:0)
 -((d.pShadow.z>tex2D(sampShadow,d.pShadow.xy+float2(-dist.y,dist.x)).x)?0.25f:0)
 ;
/*
dist*=4.0f;
for(int i=0;i<4;i++){
float2 dist1=dist*tex2D(sampNoise,d.p.xy*(1.6180339+i)).xy;
l-=((d.pShadow.z>tex2D(sampShadow,d.pShadow.xy+dist1).x)?0.25f:0);
}
*/
}

/*
//fixed distance test
const float dist=0.01f;
 l=1.0f
 -((d.pShadow.z>tex2D(sampShadow,d.pShadow.xy).x)?0.2f:0)
 -((d.pShadow.z>tex2D(sampShadow,d.pShadow.xy+float2(dist,0)).x)?0.2f:0)
 -((d.pShadow.z>tex2D(sampShadow,d.pShadow.xy+float2(-dist,0)).x)?0.2f:0)
 -((d.pShadow.z>tex2D(sampShadow,d.pShadow.xy+float2(0,dist)).x)?0.2f:0)
 -((d.pShadow.z>tex2D(sampShadow,d.pShadow.xy+float2(0,-dist)).x)?0.2f:0)
 ;
*/

#endif

//normal (normal map)
#if 1

float4 n=tex2D(sampNormal,d.t)*2.0f-1.0f;
n=n.x*d.b+n.y*d.ta+n.z*d.n; //???????? right?

#else

float4 n=d.n;

#endif

//light vector
float4 lightVec;
if(lightType==1){
 lightVec=normalize(lightPos-d.p);
}else{
 lightVec=lightDir;
}

//halfway vector
float4 h=normalize(lightVec+viewVec); //TODO:can we use "reflect"?

//TEST
l*=lit(dot(n.xyz,lightVec.xyz),dot(n.xyz,h.xyz),_fParam[1].x);
//
float4 diffuse=d.c*clr_tex*(_fParam[0]+l.y); //min(_fParam[0]+l.y,1.0f);
float4 specular=d.c1*l.z;
return float4((diffuse+specular).xyz,depth);
}

technique test{
pass{
VertexShader=compile vs_3_0 vs_func();
PixelShader=compile ps_3_0 ps_func();
}
}

////////test creating shadow map

VS_OUTPUT_SHADOW vs_func_shadow(VS_INPUT d0){
VS_OUTPUT_SHADOW d;
d._p=mul(d0.p,matShadow);
d.c=d._p; //????
//d.c=d._p.z/d._p.w+0.0001f; //eps=?
return d;
}

float4 ps_func_shadow(VS_OUTPUT_SHADOW d):COLOR0{
return d.c.z/d.c.w+0.0001f; //????
//return d.c; //????
}

technique test_shadow{
pass{
VertexShader=compile vs_2_0 vs_func_shadow();
PixelShader=compile ps_2_0 ps_func_shadow();
}
}

//TODO:density, etc.
//TODO:VFACE unsupported in ps2.0
// -- render volume in 2 steps CULL_CCW and CULL_CW :-3
float4 ps_func_volumefog(VS_OUTPUT_VOLUMEFOG d,float vf:VFACE):COLOR0{
	d.t.xyz/=d.t.w;
	float depth=1.0f/(zData.x+zData.y*d.t.z);
	//===z-test
	float4 clr_back=tex2D(samp,d.t.xy*float2(0.5f,-0.5f)+float2(0.5f,0.5f));
	depth=min(depth,clr_back.w);
	//===*/
	float4 clr=float4(depth,0,0,0)+step(vf,0)*float4(-depth,depth,0,0);
	return clr;
}

technique test_volumefog{
pass{
VertexShader=compile vs_3_0 vs_func_volumefog();
PixelShader=compile ps_3_0 ps_func_volumefog();
ZENABLE=0;ALPHABLENDENABLE=1;CULLMODE=NONE;SRCBLEND=ONE;DESTBLEND=ONE;
}
}
